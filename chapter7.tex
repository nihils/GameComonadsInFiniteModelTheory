\chapter{Conclusion}
In this dissertation, we constructed a comonad that internalized the Ehrenfreucht-{\Fraisse} game. We showed the unravelling comonad internalized modal bisimulation games. We also discussed a comonad that internalized the pebbling game. To be more precise, we showed that for any signature $\sigma$, we considered structures $A,B$ in the extended signature $\sigma' = \sigma \cup \{I\}$ with $I$ the identity relation such that: 
\begin{itemize}
\item $f:\efcomonad{k}{A} \longrightarrow B$, $g:\efcomonad{k}{B} \longrightarrow B$ are $\sigma'$-morphisms iff Duplicator can win in $\efgame{k}{A}{B}$ and $\efgame{k}{A}{B}$ iff $\equivL{A}{B}{\exists^{+}\mathcal{L}_{\omega,k}}$
    \begin{itemize}
        \item Diagram (\ref{eq:arrowSym}) commutes with $f,g$ iff Duplicator can win in $\efgameSym{k}{A}{B}$ iff $\equivL{A}{B}{\mathcal{L}_{\omega,k}}$
        \item $f$ is an isomorphism in $\mathcal{K}(\efcomonad{k}{})$ with inverse $g$ iff Duplicator can win $\efgameBij{k}{A}{B}$ iff $\equivL{A}{B}{\mathcal{L}_{\omega,k}(\mathsf{Cnt})}$
    \end{itemize}
\item $f:\pcomonad{k}{A} \longrightarrow B$, $g:\pcomonad{k}{B} \longrightarrow B$ is a $\sigma'$-morphism iff Duplicator can win in $\pgame{k}{A}{B}$ and $\pgame{k}{A}{B}$ iff $\equivL{A}{B}{\mathcal{L}^{k}_{\infty,\omega}}$
    \begin{itemize}
        \item Diagram (\ref{eq:arrowSym}) commutes with $f,g$ iff Duplicator can win in $\pgameSym{k}{A}{B}$ iff $\equivL{A}{B}{\mathcal{L}^{k}_{\infty,\omega}}$
        \item $f$ is an isomorphism in $\mathcal{K}(\efcomonad{k}{})$ with inverse $g$ iff Duplicator can win $\pgameBij{k}{A}{B}$ iff $\equivL{A}{B}{\mathcal{L}^{k}_{\infty,\omega}(\mathsf{Cnt})}$
    \end{itemize}
\end{itemize}
Restricting to $\sigma$ with only binary accessibility relations and unary predicates, we also have: 
\begin{itemize}
\item $f:\mcomonad{k}{A} \longrightarrow B$, $g:\mcomonad{k}{B} \longrightarrow A$ are $\sigma$-morphisms iff Duplicator can win in $\mgame{k}{A}{B}$ and $\mgame{k}{A}{B}$ iff $\equivL{A}{B}{\exists^{+}\mathcal{M}_{\omega,k}}$.
\item Diagram (\ref{eq:arrowSym}) commutes with $f,g$ iff Duplicator can win in $\mgameSym{k}{A}{B}$ iff $\equivL{A}{B}{\mathcal{M}_{\omega,k}}$
\item $f:\mcomonad{\omega}{A} \longrightarrow B$, $g:\mcomonad{\omega}{B} \longrightarrow A$ are $\sigma$-morphisms iff Duplicator can win in $\mgame{\omega}{A}{B}$ and $\mgame{\omega}{A}{B}$ iff $\equivL{A}{B}{\exists^{+}\mathcal{M}_{\infty,\omega}}$.
\item Diagram (\ref{eq:arrowSym}) commutes with $f,g$ iff Duplicator can win in $\mgameSym{\omega}{A}{B}$ iff $\equivL{A}{B}{\mathcal{M}_{\infty,\omega}}$
\end{itemize}
Moreover, the comonadic formulation of these games were used to give syntax-free structural proofs that $k$-rank logic is contained within the $k$-variable logic and that full modal logic is contained within $2$-variable logic. Using the category of coalgebras associated with the Ehrenfreucht-{\Fraisse} comonad, we gave a categorical definition of tree-depth. With this definition and the categorical definition of tree-width given in \cite{Abramsky2017}, we gave novel proof that tree-depth is strictly greater than tree-width.  
\section{Second-order Logic}
One of the goals of this project was to leverage results in descriptive complexity and work towards giving a category-theoretic definition of complexity classes. The main open question of complexity, and arguably computer science as a whole, is the question of $\textbf{P} \not= \textbf{NP}$. Fagin's theorem defines \textbf{NP} as an existential second-order logic. From this result, there are many open problems in descriptive complexity (e.g. Asser's problem and Gurevich's conjecture) linked to $\textbf{P} \not= \textbf{NP}$ \cite{Libkin2004}. If the work here is to shed light on these open problems, we would need to be able to generalize and modify our constructions to characterize equivalence in second-order logic. There are at least two ways we can extend this work to capture extensions of infinitary logic that are known to be equivalent to fragments of second-order logic. 
\subsection{Generalized Quantifiers}
In the previous chapters, we showed that isomorphism in the coKleisli categories of $\mathcal{K}(\efcomonad{k}{})$ and $\mathcal{K}(\pcomonad{k}{})$ characterize equivalence in $k$-rank and $k$-variable fragments of infinitary logic with counting quantifiers. Counting quantifiers are `weakly' second-order and are special case of a general way of extending first-order logic by adding syntax for additional quantifiers. A unary generalized quantifier is a isomorphism-closed class $\mathbf{Q}$ structures in signature $\tau = \{P\}$ with $P$ an unary relation. For each quantifier, we extend the syntax of infinitary logic to include clauses of form $Qx\phi(x,\mathbf{y})$ and denote this logic $\mathcal{L}_{\infty,\omega}(\mathbf{Q})$. This has the semantics, given a $\sigma$-structure $A$,  
$$A,\mathbf{d} \vDash Qx\phi(x,\mathbf{y}) \Leftrightarrow \langle |A|,\{a \in A: A,a\mathbf{d} \vDash \phi(x,\mathbf{y})\} \rangle \in \mathbf{Q} $$ 
The paper \cite{Kolaitis1995} describes a  $(k,\mathbf{Q})$-pebble game that characterizes equivalence in the $k$-variable fragment of $\mathcal{L}_{\infty,\omega}(\mathbf{Q})$. Spoiler can choose to pebble an element or pick an interpretation for the predicate $P$ in one of the structures. Duplicator must respond with an interpretation of predicate $P$ in the other structure such that for any Spoiler response in the next round, $P$ is preserved. Could this game be re-formalized in manner analogous to counting-quantifier logic? Namely, instead of requiring Duplicator to choose a bijection between $\psi:A \longrightarrow B$ at each round, Duplicator chooses a function $\psi:A \longrightarrow B$ that preserves all possible interpretations of the predicate $P$ such that $\langle A,P^{A} \rangle, \langle B,P^{B} \rangle \in \mathbf{Q}$. Future work could involve internalizing this game, and an analogous EF game, using the $\pcomonad{k}{}$ and $\efcomonad{k}{}$ comonads. The machinery of comma categories could be useful for formalizing this notion.
\subsection{Branching Quantifiers}
 Branching quantifier logic is another extension of first-order logic that is equivalent to a fragment of second-order logic. To illustrate, consider the formula $\forall x_{1} \exists y_{1} \forall x_{2} \exists y_{2} \phi(x_{1},x_{2},y_{1},y_{2})$. In this formula, the choice for a witness to $y_{2}$ could depend on $x_{1},y_{1},x_{2}$ whereas the choice for a witness to $y_{1}$ only depends on $x_{1}$. How do we express that the choice of a witness to $y_{2}$ should only depend on $x_{2}$? Branching quantifier logic adds the ability to express such dependencies. As part of the construction of $\efcomonad{k}{}$,$\pcomonad{k}{}$, and $\mcomonad{k}{}$, two Spoiler plays have to be prefix comparable to be related. Intuitively, this constraint corresponds to the fact that the EF, pebbling, and bisimulation game are games with perfect information. That is, Duplicator knows the full history of Spoiler's play when making her choice. In logic, games with imperfect information are used to model truth in branching quantifier logic. Could equivalence in branching quantifier logic also be captured by a comonad by relaxing this prefix-comparable condition?   
\section{Functional Programming}
Another goal of this project was to link concepts in finite model theory to the categorical semantics of functional programming. Many of the constructions used in this dissertation are similar to the structures employed in functional programs. Namely, every one of these comonads are variations of the list comonad. Moreover, the map $\theta_{f}$ used in the definition of positional form for the Ehrenfreucht-{\Fraisse} game involved the `diagonal' and `zipper' functions employed often in functional programs. As a proof of concept, we coded a small library in the dependently-typed Haskell-inspired language Idris. This library provides typeclasses for the $\efcomonad{k}{}$ and $\pcomonad{k}{}$ comonads. The code for these typeclasses is in the appendix. The choice to use Idris was to take advantage of its dependent-typing. Namely, the types for the EF and pebbling comonads are dependent on on natural numbers $k \in \omega$. Future work could utilize these typeclasses, in light of the results on coalgebras, to create functional algorithms for graphs of bounded tree-depth and tree-width.
